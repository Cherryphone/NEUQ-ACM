//洛谷P1255
/*
属鼠本来以为long long已经够大了没想到仍然wa了，所以属鼠意识到肯定会有一种方法专门应对这种需要输出大数的题目
于是我疯狂搜索办法，终于找到了一个叫高精度算法的东西，它的本质其实是用三个数组来模拟竖式加法的操作
把一个数字的每一位都存在数组内，每一位相加，根据加法规则进行进位计算
特别注意为了计算方便我们要把数字的每一位反向排序。
这是属鼠第一次学高精度，争取把其他几个四则运算的高精度给掌握
本题的递推思想并不难，就是简单的斐波那契数列，不多赘述
核心代码如下*/
void mplus(int ta1[],int ta2[],int ta3[])  //定义高精度加法
{
	for (int k = 2; k < 5005; k++)
	{
		ta3[k-1] += ta2[k-1] + ta1[k-1];
		ta3[k] = ta3[k-1] / 10;
		ta3[k-1] = ta3[k-1] % 10;
	}
}
void P1255()
{
	int ta1[5005] = { 0 }, ta2[5005] = { 0 }, ta3[5005] = { 0 };
	int n;
	cin >> n;
	ta1[1] = 1; ta2[1] = 2;
	for (int j = 3; j <= n; j++)
	{

		mplus(ta1, ta2, ta3);
		for (int i = 1; i < 5005; i++)//为了数列递推做好准备
		{
			ta1[i] = ta2[i];
			ta2[i] = ta3[i];
			ta3[i] = 0;
		}
	}
	int count = 5004;
	for (int i = 5004; i > 0; i--)//从数组最后开始往前回溯，碰到第一个非0数，就是这个大数的最高位
	{
		if (ta2[i] == 0)count--;
		else break;
	}
	if(n==1)
	{
	    printf("%d",1);
	    return;
	}
	else if(n==2)
	{
	    printf("%d",2);
	    return;
	}
	for (int i = count; i > 0; i--)
		printf("%d",ta2[i]);
}


//洛谷B3637这是一道入门dp题
//dp核心思想，把每一个小的子问题的结果存在一个数组f[n]中
//当去解决较大的子问题时去调用f[n]中的数据，得到的结果进一步存入f[n]
//最后逐步得到大问题的答案
//核心代码如下
#define N 5005
int f[N];//定义每一个位置下存入的数字，它的一个最优解
int num[N];
void zixulie()
{
	int n,ans=0;
	scanf("%d",&n);
	for (int i = 0; i < n; i++)
	{
		scanf("%d", &num[i]);
		f[i] = 1;                      //不妨先初始化为1，因为每个数字至少有一个长度
		                               //注意初始化为非0时候一定要一个一个初始化！
	}
	for (int i = 1; i < n; i++)
		for (int j = 0; j < i; j++)
			if (num[i] > num[j] && f[j] + 1 > f[i])
				f[i] = f[j] + 1;                  //进行操作
	for (int i = 0; i < n; i++)                               //遍历最优解数组找到最优解中的最大值
		if (f[i] > ans)ans = f[i];
	printf("%d",ans);
}



//杭电P2084
/*这是一道经典dp题目，由于该题的数据是一个数塔，我们选择二维数组来储存数据
想要找到第一个节点的最优解，只要选择第二层中的最优解即可
想要找到第二层中的最优解，只要选择第三层中的最优解即可...
最后归结为底层最优解，那么就是这个数字本身
本题关键在于找到核心的递推公式，然后从下往上遍历全局即可
f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + a[i][j]
核心代码如下*/

int f[N][N];//定义每一个节点下的最优解数组
int a[N][N];//定义存输入数塔的数组
int p[N][N] = {0};//定义路径选择数组
void numbertower()
{
	int n;
	scanf("%d", &n);
	for (int i = 0; i < n; i++)
		for (int j = 0; j <= i; j++)
			scanf("%d", &a[i][j]);//赋值初始数据
	for (int i = 0; i < n; i++)
		f[n - 1][i] = a[n - 1][i];//把f的最后一行赋值为a的最后一行，因为已经是最底层无需递推
	for (int i = n - 2; i >= 0; i--)//从子问题开始向上遍历
		for (int j = n - 2; j >= 0; j--)
			f[i][j] = max(f[i + 1][j], f[i + 1][j + 1]) + a[i][j];//从下往上递推，每次找最优，这是本题核心递推公式
	printf("%d\n", f[0][0]);
//以下是一个找最优路径的办法
	//把0定位往左走，把1定为向右走
	for (int i = 0; i < n; i++)
		for (int j = 0; j <= i; j++)
			p[i][j] = f[i + 1][j] > f[i + 1][j + 1] ? 0 : 1;   //核心递推公式
	printf("%d ", a[0][0]);
	int j = 0;
	for (int i = 0; i < n - 1; i++)
	{
		if (p[i][j] == 0)printf("%d", a[i + 1][j]);
		else
		{
			printf("%d ", a[i + 1][j + 1]);
			j++;
		}
	}
}

//洛谷P1255
/*
属鼠本来以为long long已经够大了没想到仍然wa了，所以属鼠意识到肯定会有一种方法专门应对这种需要输出大数的题目
于是我疯狂搜索办法，终于找到了一个叫高精度算法的东西，它的本质其实是用三个数组来模拟竖式加法的操作
把一个数字的每一位都存在数组内，每一位相加，根据加法规则进行进位计算
特别注意为了计算方便我们要把数字的每一位反向排序。
这是属鼠第一次学高精度，争取把其他几个四则运算的高精度给掌握
本题的递推思想并不难，就是简单的斐波那契数列，不多赘述
核心代码如下*/
void mplus(int ta1[],int ta2[],int ta3[])  //定义高精度加法
{
	for (int k = 2; k < 5005; k++)
	{
		ta3[k-1] += ta2[k-1] + ta1[k-1];
		ta3[k] = ta3[k-1] / 10;
		ta3[k-1] = ta3[k-1] % 10;
	}
}
void P1255()
{
	int ta1[5005] = { 0 }, ta2[5005] = { 0 }, ta3[5005] = { 0 };
	int n;
	cin >> n;
	ta1[1] = 1; ta2[1] = 2;
	for (int j = 3; j <= n; j++)
	{

		mplus(ta1, ta2, ta3);
		for (int i = 1; i < 5005; i++)//为了数列递推做好准备
		{
			ta1[i] = ta2[i];
			ta2[i] = ta3[i];
			ta3[i] = 0;
		}
	}
	int count = 5004;
	for (int i = 5004; i > 0; i--)//从数组最后开始往前回溯，碰到第一个非0数，就是这个大数的最高位
	{
		if (ta2[i] == 0)count--;
		else break;
	}
	if(n==1)
	{
	    printf("%d",1);
	    return;
	}
	else if(n==2)
	{
	    printf("%d",2);
	    return;
	}
	for (int i = count; i > 0; i--)
		printf("%d",ta2[i]);
}
